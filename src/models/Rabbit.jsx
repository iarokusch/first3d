/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: maxpanysh (https://sketchfab.com/maxpanysh)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/silent-ash-bc44272e8c1047148b33c913e659fcfa
Title: Silent Ash
*/

import React, { useRef, useEffect, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { a } from '@react-spring/three'
import RabbitScene from '../assets/3d/silent_ash.glb'


const Rabbit = ({ isRotating, setIsRotating, setCurrentStage, ...props }) => {

    const rabbitRef = useRef();
    const skateboardRef = useRef();
    const initialPosition = useRef([0, 0, 0]);



    const { nodes, materials } = useGLTF(RabbitScene);

    const { gl, viewport } = useThree()
    const lastX = useRef(0)
    const rotationSpeed = useRef(0)
    const dampigFactor = 0.95

    useEffect(() => {
        initialPosition.current = rabbitRef.current.position.toArray();
    }, []);



    const handlePointerDown = (e) => {
        e.stopPropagation()
        e.preventDefault()
        setIsRotating(true)
        const clientX = e.touches ? e.touches[0].clientX : e.clientX
        lastX.current = clientX
    }
    const handlePointerUp = (e) => {
        e.stopPropagation()
        e.preventDefault()
        setIsRotating(false)

    }
    const handlePointerMove = (e) => {
        e.stopPropagation()
        e.preventDefault()
        if (isRotating) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX
            const delta = (clientX - lastX.current) / viewport.width
            rabbitRef.current.rotation.y += delta * 0.001 * Math.PI

            // skateboardRef.current.rotation.y += delta * 0.001 * Math.PI;
        }
    }



    const handleKeyDown = (e) => {
        if (e.key === 'ArrowLeft') {
            if (!isRotating) setIsRotating(true);
            rabbitRef.current.rotation.y += 0.01 * Math.PI
        } else if (e.key === 'ArrowRight') {
            if (!isRotating) setIsRotating(true)
            rabbitRef.current.rotation.y -= 0.01 * Math.PI
        }
    }
    const handleKeyUp = (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            setIsRotating(false)
        }
    }

    useFrame(() => {
        if (!isRotating) {
            rotationSpeed.current *= dampigFactor

            if (Math.abs(rotationSpeed.current) < 0.001) {
                rotationSpeed.current = 0
            }
        } else {
            const rotation = rabbitRef.current.rotation.y


            if (rabbitRef.current.position.y >= 9 || rabbitRef.current.position.y <= -9) {
                rabbitRef.current.position.set(...initialPosition.current);
            } else {
                rabbitRef.current.rotation.y += 0.07;
                rabbitRef.current.position.y += 0.1;
            }





            if (skateboardRef.current.position.y >= 0.9) {
                skateboardRef.current.position.y = 0


            } else {
                skateboardRef.current.rotation.y += 0.3;
                skateboardRef.current.position.y = 0;

            }
            // if (rabbitRef.current.position.y >= 9) {
            //     rabbitRef.current.position.y -= 7


            // } else {
            //     rabbitRef.current.rotation.y += 0.07;
            //     rabbitRef.current.position.y += 0.1;

            // }


            /**
    * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
    * The goal is to ensure that the rotation value remains within a specific range to
    * prevent potential issues with very large or negative rotation values.
    *  Here's a step-by-step explanation of what this code does:
    *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
    *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
    *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
    *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
    *     This is done to ensure that the value remains positive and within the range of
    *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
    *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
    *     modulo operation to the value obtained in step 2. This step guarantees that the value
    *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
    *     circle in radians.
    */
            const normalizedRotation =
                ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

            // Set the current stage based on the island's orientation
            switch (true) {
                case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
                    setCurrentStage(1);
                    break;
                case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
                    setCurrentStage(2);
                    break;
                case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
                    setCurrentStage(3);
                    break;
                case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
                    setCurrentStage(4);
                    break;
                default:
                    setCurrentStage(null);
            }
        }
    });


    useEffect(() => {
        const canvas = gl.domElement
        canvas.addEventListener('pointerdown', handlePointerDown)
        canvas.addEventListener('pointerup', handlePointerUp)
        canvas.addEventListener('pointermove', handlePointerMove)
        document.addEventListener('keyup', handleKeyUp)
        document.addEventListener('keydown', handleKeyDown)
        return () => {
            canvas.removeEventListener('pointerdown', handlePointerDown)
            canvas.removeEventListener('pointerup', handlePointerUp)
            canvas.removeEventListener('pointermove', handlePointerMove)
            document.addEventListener('keyup', handleKeyUp)
            document.addEventListener('keydown', handleKeyDown)
        }
    }, [gl, handlePointerDown, handlePointerUp, handlePointerMove])

    return (
        <a.group ref={rabbitRef} {...props} >
            <group rotation={[-Math.PI / 2, 0, 0]} scale={0.398}>
                <group rotation={[Math.PI / 2, 0, 0]}>
                    <group position={[0.002, 2.616, 0.003]}>
                        <mesh
                            ref={rabbitRef}
                            geometry={nodes.Object_4.geometry}
                            material={materials.Bunny}
                        />

                        <mesh
                            ref={skateboardRef}
                            geometry={nodes.Object_5.geometry}
                            material={materials.Skateboard}
                        />
                    </group>
                </group>
            </group>
        </a.group>
    );
}


export default Rabbit